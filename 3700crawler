#!/usr/bin/env python3

import argparse
from asyncio import sleep
import socket, ssl
from html.parser import HTMLParser

DEFAULT_SERVER = "proj5.3700.network"
DEFAULT_PORT = 443

class Parser(HTMLParser):
    # record of paths weve discovered
    links_found = ['/']
    flags_found = []
    recording = 0

    # attrs is a list of tuples
    def handle_starttag(self, tag, attrs):
        # a tags provide the next paths to crawl
        if (tag == 'a'):
            for tuple in attrs:
                href = tuple[1]
                if href[0] == '/' and href not in Crawler.links_crawled:   # we only care about crawling links in this domain... should be a path within it
                    self.links_found.append(tuple[1])
        # right now, we only care about the input tags for the csrfmiddlewaretoken on login page
        if (tag == 'input'):
            if ('name', 'csrfmiddlewaretoken') in attrs:
                for tuple in attrs:
                    if tuple[0] == 'value':
                        Crawler.csrfmiddlewaretoken = tuple[1]
        if (tag == 'h2'):
                self.recording = 1

    def handle_endtag(self, tag):
        if (tag == "h2"):
            self.recording -= 1

    def handle_data(self, data):
        if self.recording:
            if data.startswith("FLAG"):
                self.flags_found.append(data)
                print(data) # print the flag
                            
class Crawler:
    sock = None
    parser = None
    csrfmiddlewaretoken = None
    csrftoken = None
    sessionid = None
    next_req = None

    # record of paths weve crawled (had successful GET request for)
    links_crawled = ['/']
    current_link = ""

    def __init__(self, args):
        self.server = args.server
        self.port = args.port
        self.username = args.username
        self.password = args.password

    def my_recv(self):
        chunked = False
        buffer = ''
        while "</html>" not in buffer: 
            data = self.sock.recv(1024).decode('ascii')
            if not data:
                break
            buffer += data
            if ("chunked" in buffer):
                chunked = True
                # message body will end with "0"
                # then possibly footers

        return buffer

    def send_req(self, request):
        #print('\n\nMAKING REQ:\n%s' % request)
        self.sock.send(request.encode('ascii'))
        
    def get_response(self):
        try:
            res = self.my_recv()
            #print("RESPONSE:\n%s" % res)
            self.parser.feed(res)
            self.parser.close()
            return res
        except:
           print('could not my_recv')

    def login_POST(self):
        if (self.sessionid is None or self.csrftoken is None or self.csrfmiddlewaretoken is None):
            print('cannot POST, missing necessary login data')

        initial = "POST /accounts/login/?next=/fakebook/ HTTP/1.1"
        body = "username=%s&password=%s&csrfmiddlewaretoken=%s&next=/fakebook/" % (self.username, self.password, self.csrfmiddlewaretoken)

        # headers
        c_length = "Content-Length: %d" % len(body)
        c_type = "Content-Type: application/x-www-form-urlencoded"
        keepalive = "Connection: close"
        cookie = "Cookie: csrftoken=%s; sessionid=%s;" % (self.csrftoken, self.sessionid)
        host = "Host: %s:%s" % (DEFAULT_SERVER, DEFAULT_PORT)

        return initial + "\r\n" + cookie + "\r\n" + c_length + "\r\n" + c_type + "\r\n" + keepalive + "\r\n" + host + "\r\n\r\n" + body + "\r\n\r\n"

    def perform_login(self):
        # first GET /accounts/login/ for cookie data
        try:
            self.send_req("GET /accounts/login/ HTTP/1.1\r\nHost: proj5.3700.network:443\r\nConnection: keep-alive\r\n\r\n")
            res = self.get_response()
            self.links_crawled.append('/accounts/login/')

            sid_i = res.index("sessionid=") + 10
            self.sessionid = res[sid_i:sid_i + 32] # len(sessionid) = 32

            tok_i = res.index("csrftoken=")+ 10
            self.csrftoken = res[tok_i:tok_i + 64] # len(sessionid) = 64

            try: # then POST /accounts/login/ to log in
                self.send_req(self.login_POST())
                res = self.get_response()
                return res
            except:
                print('POST login err')
        except:
            print('GET login err')

    def pickLink(self):
        links_to_search = set(self.parser.links_found) - set(self.links_crawled)
        links_to_search.remove("/accounts/logout/")
        if len(links_to_search) == 0:
            print("NO MORE LINKS TO SEARCH")
        return links_to_search.pop()

    def responseStatus(self, response):
        next_request = None
        #print('len response:', len(response))
        if response != '':
            into_lines = response.split('\r\n')
            if (into_lines[0] == '\n'):
                into_lines.remove('\n')
            first_line = into_lines[0].split(" ")
            status = first_line[1]

            #print("FOUND FLAGS: ", self.parser.flags_found)

            if status[0] == "2":
                #print("status is 2XX. Everything is OK.\n")
                link = self.pickLink()
                next_request = self.createRequest("GET", link)
                self.links_crawled.append(link)
                self.current_link = link

            if status[0] == "3":
                #print("status is 3XX. HTTP redirect. \n")

                sid_i = response.index("sessionid=") + 10
                self.sessionid = response[sid_i:sid_i + 32]  # len(sessionid) = 32

                tok_i = response.index("csrftoken=") + 10
                self.csrftoken = response[tok_i:tok_i + 64]  # len(sessionid) = 64

                next_request = self.handleRedirects(response)

            if status[0] == "4":
                print("status is 4XX. Forbidden or Not Found. Abandon the url.\n")  
                
            if status[0] == "5":
                #print("status is 5XX. Service unavailable. Resend request.\n")
                next_request = self.createRequest("GET", self.current_link)
        
            return next_request


    def refreshSocket(self):
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        contextInstance = ssl.SSLContext()
        self.sock = contextInstance.wrap_socket(s)
        self.sock.connect((self.server, self.port))

    def handleRedirects(self, response):
        response_into_lines = response.split('\r\n')
        location_line = response_into_lines[6]
        location = location_line.split(' ')[1]
        self.current_link = location
        new_request = self.createRequest("GET", location)
        return new_request


    def createRequest(self, request_type, location):
        initial = request_type + " " + location + " " + "HTTP/1.1"
        keepalive = "Connection: keep-alive"
        cookie = "Cookie: csrftoken=%s; sessionid=%s;" % (self.csrftoken, self.sessionid)
        host = "Host: %s:%s" % (DEFAULT_SERVER, DEFAULT_PORT)

        return initial + "\r\n" + cookie + "\r\n" + host + "\r\n" + keepalive + "\r\n\r\n"

    def run(self):
        # instantiate socket with tls for HTTPS
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        contextInstance = ssl.SSLContext()
        self.sock = contextInstance.wrap_socket(s)
        self.sock.connect((self.server, self.port))
        self.parser = Parser()

        post_res = self.perform_login() # POST closes connection afterwards
        self.next_req = self.responseStatus(post_res)
        self.refreshSocket() # create socket for the rest of crawling

        connected = True
        more_flags = True
        while more_flags:  
            try:  
                self.send_req(self.next_req)
                res = self.get_response()
                self.next_req = self.responseStatus(res) 
                if (len(self.parser.flags_found) == 5):
                    more_flags = False
            except socket.error:  
                print( "connection lost... reconnecting" )  
                connected = False  
                s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                contextInstance = ssl.SSLContext()
                self.sock = contextInstance.wrap_socket(s)

                while not connected:  
                    # attempt to reconnect, otherwise sleep for 2 seconds  
                    try:  
                        self.sock.connect((self.server, self.port))
                        connected = True  
                        print( "re-connection successful" )  
                    except socket.error:  
                        sleep(2)  

        #print("FOUND FLAGS: ", self.parser.flags_found)
        #print("AMOUNT OF LINKS CRAWLED: ", len(self.links_crawled))
        
        self.sock.close()

        
       

if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='crawl Fakebook')
    parser.add_argument('-s', dest="server", type=str, default=DEFAULT_SERVER, help="The server to crawl")
    parser.add_argument('-p', dest="port", type=int, default=DEFAULT_PORT, help="The port to use")
    parser.add_argument('username', type=str, help="The username to use")
    parser.add_argument('password', type=str, help="The password to use")
    args = parser.parse_args()
    sender = Crawler(args)
    sender.run()
